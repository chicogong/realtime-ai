<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时AI对话</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            height: 100vh;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .status-container {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .status {
            font-size: 14px;
            color: #666;
        }
        
        .status.listening {
            color: #2ecc71;
        }
        
        .status.thinking {
            color: #3498db;
        }
        
        .status.error {
            color: #e74c3c;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            background-color: #3498db;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        button.stop {
            background-color: #e74c3c;
        }
        
        button.stop:hover {
            background-color: #c0392b;
        }
        
        .chat-container {
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .input-area {
            display: flex;
            border-top: 1px solid #eee;
            padding: 10px;
        }
        
        .message {
            margin-bottom: 15px;
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 18px;
            line-height: 1.4;
        }
        
        .user-message {
            align-self: flex-end;
            background-color: #3498db;
            color: white;
            margin-left: auto;
        }
        
        .ai-message {
            background-color: #f1f1f1;
            color: #333;
        }
        
        .typing-indicator {
            display: inline-block;
        }
        
        .typing-indicator span {
            height: 5px;
            width: 5px;
            margin-right: 3px;
            border-radius: 50%;
            background-color: #bdc3c7;
            display: inline-block;
            animation: typingPulse 1s infinite ease-in-out;
        }
        
        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.listening {
            background-color: #2ecc71;
            box-shadow: 0 0 5px #2ecc71;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.thinking {
            background-color: #3498db;
            box-shadow: 0 0 5px #3498db;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.idle {
            background-color: #95a5a6;
        }
        
        .status-dot.error {
            background-color: #e74c3c;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes typingPulse {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>实时AI对话</h1>
        
        <div class="status-container">
            <div class="status">
                <span class="status-dot idle" id="status-dot"></span>
                <span id="status-text">准备就绪</span>
            </div>
        </div>
        
        <div class="chat-container">
            <div class="messages" id="messages"></div>
            <div class="input-area">
                <div id="partial-transcript"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn">开始对话</button>
            <button id="stop-btn" class="stop" disabled>停止对话</button>
            <button id="reset-btn">重置</button>
        </div>
    </div>
    
    <script>
        // Audio configuration
        const SAMPLE_RATE = 16000;
        const SAMPLE_SIZE = 16;
        const CHANNELS = 1;
        const BUFFER_SIZE = 4096;
        
        // WebSocket and recording variables
        let socket = null;
        let mediaStream = null;
        let audioContext = null;
        let processor = null;
        let isRecording = false;
        
        // 是否需要重采样
        let resampleRequired = false;
        let originalSampleRate = 0;
        
        // AI响应状态
        let isAIResponding = false;
        
        // DOM elements
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const resetBtn = document.getElementById('reset-btn');
        const partialTranscript = document.getElementById('partial-transcript');
        const messages = document.getElementById('messages');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        
        // 音频相关
        let isPlayingAudio = false;
        let currentAudioSource = null;
        let audioBufferQueue = [];
        
        // 初始化音频上下文
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(`音频上下文已初始化，采样率: ${audioContext.sampleRate}Hz`);
                    return true;
                } catch (e) {
                    console.error('初始化音频上下文失败:', e);
                    return false;
                }
            } else if (audioContext.state === "suspended") {
                audioContext.resume().catch(console.error);
            }
            return true;
        }
        
        // Initialize WebSocket connection
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(event) {
                console.log('WebSocket连接成功');
                updateStatus('idle', '已连接，准备就绪');
                startBtn.disabled = false;
                
                // 确保音频上下文已初始化
                initAudioContext();
            };
            
            socket.onmessage = function(event) {
                try {
                    // 判断消息类型（文本或二进制）
                    if (typeof event.data === 'string') {
                        // JSON消息
                        const data = JSON.parse(event.data);
                        
                        // 处理普通JSON消息
                        handleSocketMessage(data);
                    } else if (event.data instanceof Blob) {
                        // 处理二进制音频数据
                        handleBinaryAudioData(event.data);
                    }
                } catch (e) {
                    console.error('处理消息时出错:', e);
                }
            };
            
            socket.onclose = function(event) {
                console.log('WebSocket连接关闭');
                updateStatus('error', '连接已断开');
                startBtn.disabled = true;
                stopBtn.disabled = true;
                isRecording = false;
                
                // 5秒后尝试重连
                setTimeout(function() {
                    console.log('尝试重新连接...');
                    initializeWebSocket();
                }, 5000);
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket错误:', error);
                updateStatus('error', '连接错误');
            };
        }
        
        // 处理WebSocket消息
        function handleSocketMessage(data) {
            switch (data.type) {
                case 'partial_transcript':
                    partialTranscript.textContent = data.content;
                    break;
                
                case 'final_transcript':
                    addMessage(data.content, 'user');
                    partialTranscript.textContent = '';
                    break;
                
                case 'llm_status':
                    if (data.status === 'processing') {
                        updateStatus('thinking', 'AI思考中...');
                        isAIResponding = true;
                        
                        // 显示AI正在输入
                        const typingMessage = document.createElement('div');
                        typingMessage.id = 'ai-typing';
                        typingMessage.className = 'message ai-message';
                        typingMessage.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
                        messages.appendChild(typingMessage);
                        messages.scrollTop = messages.scrollHeight;
                    }
                    break;
                
                case 'llm_response':
                    // 删除输入指示器
                    const typingIndicator = document.getElementById('ai-typing');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                    
                    // 处理响应
                    if (data.is_complete) {
                        // 完整响应
                        addMessage(data.content, 'ai');
                        updateStatus('idle', '已完成');
                        isAIResponding = false;
                    }
                    break;
                
                case 'tts_sentence_start':
                    console.log(`开始处理新句子: ${data.text}, ID: ${data.sentence_id}`);
                    break;
                
                case 'tts_sentence_end':
                    console.log(`句子处理结束: ID: ${data.sentence_id}`);
                    break;
                
                case 'status':
                    if (data.status === 'listening') {
                        updateStatus('listening', '正在听取...');
                    } else if (data.status === 'stopped') {
                        updateStatus('idle', '已停止');
                    }
                    break;
                
                case 'error':
                    console.error('Server error:', data.message);
                    updateStatus('error', `错误: ${data.message}`);
                    break;
                
                case 'server_interrupt':
                    console.log("收到服务器打断信令:", data.message);
                    stopAudioPlayback();
                    updateStatus('listening', '已打断，正在听取...');
                    isAIResponding = false;
                    break;
            }
        }
        
        // 处理二进制音频数据
        async function handleBinaryAudioData(blob) {
            try {
                // 确保音频上下文已初始化
                initAudioContext();
                
                // 解析二进制数据
                const arrayBuffer = await blob.arrayBuffer();
                
                // 检查数据大小
                if (arrayBuffer.byteLength < 12) {
                    console.error('收到的二进制数据太小，无法解析头部');
                    return;
                }
                
                // 解析头部信息
                // 格式: [4字节请求ID][4字节块序号][4字节时间戳][PCM数据]
                const headerView = new DataView(arrayBuffer, 0, 12);
                const requestId = headerView.getUint32(0, true);  // 使用小端字节序
                const chunkNumber = headerView.getUint32(4, true);
                const timestamp = headerView.getUint32(8, true);
                
                // 提取PCM数据
                const pcmData = arrayBuffer.slice(12);
                
                // 打印日志
                console.log(`处理音频块: ID=${requestId}, 块号=${chunkNumber}, 时间戳=${timestamp}, PCM大小=${pcmData.byteLength}字节`);
                
                // 播放PCM数据
                playAudio(pcmData);
            } catch (e) {
                console.error('处理二进制音频数据出错:', e);
            }
        }
        
        // 停止当前音频播放
        function stopAudioPlayback() {
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                    currentAudioSource = null;
                } catch (e) {
                    console.error('停止音频错误:', e);
                }
            }
            isPlayingAudio = false;
            audioBufferQueue = [];
        }
        
        // 音频播放
        function playAudio(audioData) {
            if (!initAudioContext()) {
                console.error('无法初始化音频上下文');
                return;
            }
            
            try {
                if (!audioData || audioData.byteLength === 0) {
                    console.warn('收到空音频数据');
                    return;
                }
                
                console.log(`播放音频数据: ${audioData.byteLength} 字节`);
                
                // 如果有正在播放的音频，加入队列
                if (isPlayingAudio && currentAudioSource) {
                    audioBufferQueue.push(audioData);
                    console.log(`音频已加入队列，当前队列长度: ${audioBufferQueue.length}`);
                    return;
                }
                
                // 创建音频缓冲区
                pcmToAudioBuffer(audioData).then(audioBuffer => {
                    if (!audioBuffer) {
                        console.error('创建音频缓冲区失败');
                        return;
                    }
                    
                    // 创建音频源
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    
                    // 直接连接到输出
                    source.connect(audioContext.destination);
                    
                    // 保存当前音频源
                    currentAudioSource = source;
                    isPlayingAudio = true;
                    
                    // 添加播放结束事件处理
                    source.onended = () => {
                        console.log('音频播放结束');
                        currentAudioSource = null;
                        isPlayingAudio = false;
                        
                        // 播放队列中的下一个
                        if (audioBufferQueue.length > 0) {
                            const nextBuffer = audioBufferQueue.shift();
                            playAudio(nextBuffer);
                        }
                    };
                    
                    // 开始播放
                    source.start(0);
                    console.log('开始播放音频');
                }).catch(err => {
                    console.error('创建或播放音频缓冲区时出错:', err);
                    isPlayingAudio = false;
                    
                    // 尝试处理下一个音频
                    if (audioBufferQueue.length > 0) {
                        const nextBuffer = audioBufferQueue.shift();
                        playAudio(nextBuffer);
                    }
                });
            } catch (e) {
                console.error('播放音频错误:', e);
                isPlayingAudio = false;
                
                // 错误处理后尝试播放下一个
                if (audioBufferQueue.length > 0) {
                    setTimeout(() => {
                        const nextBuffer = audioBufferQueue.shift();
                        playAudio(nextBuffer);
                    }, 500);
                }
            }
        }
        
        // 将PCM数据转换为AudioBuffer
        async function pcmToAudioBuffer(pcmData) {
            if (!initAudioContext()) {
                return null;
            }
            
            try {
                // 检查PCM数据是否有效
                if (!pcmData || pcmData.byteLength === 0) {
                    console.warn('PCM数据无效');
                    return null;
                }
                
                // 获取实际上下文采样率，可能需要重采样
                const contextRate = audioContext.sampleRate;
                const sourceRate = 16000; // Azure TTS是16kHz
                const needsResampling = contextRate !== sourceRate;
                
                // 创建临时AudioBuffer用于初始PCM数据
                const tempBuffer = audioContext.createBuffer(
                    1,                        // 单声道
                    pcmData.byteLength / 2,   // 16位=2字节每样本，所以字节数/2=样本数
                    sourceRate                // 源采样率16kHz
                );
                
                // 获取音频通道数据
                const tempChannelData = tempBuffer.getChannelData(0);
                
                // 将PCM数据转换为Float32Array，确保处理小端字节序
                const dataView = new DataView(pcmData);
                for (let i = 0; i < tempChannelData.length; i++) {
                    // 使用getInt16显式指定小端字节序(true)，避免字节序问题
                    const int16Value = dataView.getInt16(i * 2, true);
                    // 16位PCM范围是-32768到32767，转换到-1.0到1.0
                    tempChannelData[i] = int16Value / 32768.0;
                }
                
                // 如果需要重采样
                if (needsResampling) {
                    console.log(`重采样从 ${sourceRate}Hz 到 ${contextRate}Hz`);
                    
                    // 创建目标AudioBuffer
                    const targetSampleCount = Math.round(tempChannelData.length * contextRate / sourceRate);
                    const targetBuffer = audioContext.createBuffer(1, targetSampleCount, contextRate);
                    const targetChannelData = targetBuffer.getChannelData(0);
                    
                    // 简单线性内插重采样
                    for (let i = 0; i < targetSampleCount; i++) {
                        const sourcePos = i * sourceRate / contextRate;
                        const sourcePosFloor = Math.floor(sourcePos);
                        const fraction = sourcePos - sourcePosFloor;
                        
                        // 确保不越界
                        if (sourcePosFloor < tempChannelData.length - 1) {
                            const a = tempChannelData[sourcePosFloor];
                            const b = tempChannelData[sourcePosFloor + 1];
                            // 线性插值
                            targetChannelData[i] = a + fraction * (b - a);
                        } else if (sourcePosFloor < tempChannelData.length) {
                            targetChannelData[i] = tempChannelData[sourcePosFloor];
                        }
                    }
                    
                    return targetBuffer;
                }
                
                // 如果不需要重采样，直接返回原始buffer
                return tempBuffer;
            } catch (e) {
                console.error('PCM转换失败:', e);
                return null;
            }
        }
        
        // 添加消息到对话框
        function addMessage(text, type) {
            const message = document.createElement('div');
            message.className = `message ${type}-message`;
            message.textContent = text;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;
        }
        
        // 更新状态指示器
        function updateStatus(state, message) {
            statusDot.className = `status-dot ${state}`;
            statusText.textContent = message;
        }
        
        // 重采样函数
        function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) {
                return buffer;
            }
            
            const sampleRateRatio = inputSampleRate / outputSampleRate;
            const newLength = Math.round(buffer.length / sampleRateRatio);
            const result = new Float32Array(newLength);
            
            let offsetResult = 0;
            let offsetBuffer = 0;
            
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                let accum = 0, count = 0;
                
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                    accum += buffer[i];
                    count++;
                }
                
                result[offsetResult] = accum / count;
                offsetResult++;
                offsetBuffer = nextOffsetBuffer;
            }
            
            return result;
        }
        
        // 从Float32转换为Int16 (PCM)
        function convertFloat32ToInt16(buffer) {
            const l = buffer.length;
            const buf = new Int16Array(l);
            
            for (let i = 0; i < l; i++) {
                const s = Math.max(-1, Math.min(1, buffer[i]));
                buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            return buf;
        }
        
        // 检测音频电平
        function detectAudioLevel(audioBuffer) {
            let sum = 0;
            for (let i = 0; i < audioBuffer.length; i++) {
                sum += Math.abs(audioBuffer[i]);
            }
            return sum / audioBuffer.length;
        }
        
        // 开始录音
        async function startRecording() {
            try {
                // 请求麦克风访问权限
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                // 创建音频上下文
                if (!initAudioContext()) {
                    throw new Error('无法初始化音频上下文');
                }
                
                originalSampleRate = audioContext.sampleRate;
                
                // 检查是否需要重采样
                resampleRequired = originalSampleRate !== SAMPLE_RATE;
                console.log(`原始采样率: ${originalSampleRate}Hz, 目标采样率: ${SAMPLE_RATE}Hz, 需要重采样: ${resampleRequired}`);
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                
                // 创建处理节点
                processor = audioContext.createScriptProcessor(BUFFER_SIZE, CHANNELS, CHANNELS);
                
                processor.onaudioprocess = function(e) {
                    if (!isRecording || !socket || socket.readyState !== WebSocket.OPEN) return;
                    
                    // 获取音频数据
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // 检测用户是否在AI响应时开始说话
                    if (isAIResponding) {
                        const audioLevel = detectAudioLevel(inputData);
                        if (audioLevel > 0.05) {
                            if (socket.readyState === WebSocket.OPEN) {
                                socket.send(JSON.stringify({ type: "interrupt" }));
                            }
                            isAIResponding = false;
                        }
                    }
                    
                    // 根据需要重采样
                    let audioToProcess = inputData;
                    if (resampleRequired) {
                        audioToProcess = downsampleBuffer(inputData, originalSampleRate, SAMPLE_RATE);
                    }
                    
                    // 转换为16位PCM
                    const pcmData = convertFloat32ToInt16(audioToProcess);
                    
                    // 发送到服务器
                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(pcmData.buffer);
                    }
                };
                
                // 连接音频节点
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                updateStatus('listening', '正在听取...');
                
                // 更新UI
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                // 发送开始命令
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'start' }));
                }
                
            } catch (error) {
                console.error('Error starting recording:', error);
                updateStatus('error', '麦克风访问错误');
            }
        }
        
        // 停止录音
        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            
            // 停止媒体流
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            
            // 断开音频节点
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            
            // 不关闭音频上下文，以便继续播放TTS
            if (audioContext && audioContext.state === "running" && !isPlayingAudio) {
                audioContext.suspend().catch(console.error);
            }
            
            // 发送停止命令
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'stop' }));
            }
            
            // 更新UI
            startBtn.disabled = false;
            stopBtn.disabled = true;
            updateStatus('idle', '已停止');
        }
        
        // 重置所有内容
        function resetSession() {
            // 停止录音（如果正在进行）
            if (isRecording) {
                stopRecording();
            }
            
            // 停止所有正在播放的音频
            stopAudioPlayback();
            
            // 清空显示
            partialTranscript.textContent = '';
            messages.innerHTML = '';
            
            // 发送重置命令
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: "reset" }));
            }
            
            updateStatus('idle', '已重置');
        }
        
        // 事件监听器
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        resetBtn.addEventListener('click', resetSession);
        
        // 单击文档时唤醒音频上下文
        document.addEventListener('click', function() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(console.error);
            }
        });
        
        // 初始化连接
        window.addEventListener('load', function() {
            initializeWebSocket();
        });
        
        // 处理页面卸载
        window.addEventListener('beforeunload', () => {
            if (isRecording) {
                stopRecording();
            }
            if (socket) {
                socket.close();
            }
            if (audioContext) {
                audioContext.close().catch(console.error);
            }
        });
    </script>
</body>
</html> 