<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure ASR & LLM å­—å¹•æ¼”ç¤º</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            height: 100vh;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .status-container {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .status {
            font-size: 14px;
            color: #666;
        }
        
        .status.listening {
            color: #2ecc71;
        }
        
        .status.thinking {
            color: #3498db;
        }
        
        .status.error {
            color: #e74c3c;
        }
        
        .controls {
            margin-bottom: 30px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            background-color: #3498db;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        button.stop {
            background-color: #e74c3c;
        }
        
        button.stop:hover {
            background-color: #c0392b;
        }
        
        .subtitle-container {
            width: 100%;
            min-height: 120px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        
        .partial-transcript {
            font-size: 24px;
            margin-bottom: 10px;
            min-height: 36px;
            color: #f1c40f;
        }
        
        .final-transcript {
            font-size: 16px;
            color: #bdc3c7;
            margin-top: 10px;
            font-style: italic;
        }
        
        .llm-response-container {
            width: 100%;
            min-height: 120px;
            border-radius: 8px;
            background-color: rgba(52, 73, 94, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            transition: opacity 0.3s;
        }
        
        .llm-response {
            font-size: 20px;
            color: #ecf0f1;
            line-height: 1.5;
        }
        
        .llm-status {
            font-size: 14px;
            color: #bdc3c7;
            margin-top: 10px;
            font-style: italic;
        }
        
        .history-container {
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .history-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .history-item-user {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            color: #2c3e50;
        }
        
        .history-item-llm {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            color: #8e44ad;
            padding-left: 15px;
        }
        
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.listening {
            background-color: #2ecc71;
            box-shadow: 0 0 5px #2ecc71;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.thinking {
            background-color: #3498db;
            box-shadow: 0 0 5px #3498db;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.idle {
            background-color: #95a5a6;
        }
        
        .status-dot.error {
            background-color: #e74c3c;
        }

        .browser-warning {
            background-color: #ffeaa7;
            border-left: 4px solid #fdcb6e;
            padding: 10px 15px;
            margin-bottom: 20px;
            border-radius: 0 4px 4px 0;
            display: none;
        }
        
        .typing-indicator {
            display: inline-block;
        }
        
        .typing-indicator span {
            height: 5px;
            width: 5px;
            margin-right: 3px;
            border-radius: 50%;
            background-color: #bdc3c7;
            display: inline-block;
            animation: typingPulse 1s infinite ease-in-out;
        }
        
        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
            100% {
                opacity: 1;
            }
        }
        
        @keyframes typingPulse {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Azure ASR & LLM å­—å¹•æ¼”ç¤º</h1>
        
        <div id="browser-warning" class="browser-warning">
            <strong>æ³¨æ„:</strong> æœ¬åº”ç”¨éœ€è¦ä½¿ç”¨æ”¯æŒéŸ³é¢‘APIçš„ç°ä»£æµè§ˆå™¨ï¼Œå¹¶ä¸”éœ€è¦å…è®¸éº¦å…‹é£è®¿é—®æƒé™ã€‚è¯·ä½¿ç”¨Chromeã€Edgeæˆ–Firefoxçš„æœ€æ–°ç‰ˆæœ¬ã€‚
        </div>
        
        <div class="status-container">
            <div class="status">
                <span class="status-dot idle" id="status-dot"></span>
                <span id="status-text">å‡†å¤‡å°±ç»ª</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn">å¼€å§‹å½•éŸ³</button>
            <button id="stop-btn" class="stop" disabled>åœæ­¢å½•éŸ³</button>
            <button id="reset-btn">é‡ç½®</button>
        </div>
        
        <div class="subtitle-container">
            <div class="partial-transcript" id="partial-transcript"></div>
            <div class="final-transcript" id="final-transcript"></div>
        </div>
        
        <div class="llm-response-container">
            <div class="llm-response" id="llm-response"></div>
            <div class="llm-status" id="llm-status"></div>
        </div>
        
        <div class="history-container" id="history-container">
            <h3>å¯¹è¯å†å²</h3>
            <div id="history"></div>
        </div>
    </div>
    
    <script>
        // Audio configuration
        const SAMPLE_RATE = 16000;  // Azureéœ€è¦16kHzé‡‡æ ·ç‡
        const SAMPLE_SIZE = 16;
        const CHANNELS = 1;
        const BUFFER_SIZE = 4096;
        
        // WebSocket and recording variables
        let socket = null;
        let mediaStream = null;
        let audioContext = null;
        let processor = null;
        let isRecording = false;
        
        // å¦‚æœæµè§ˆå™¨çš„éŸ³é¢‘é‡‡æ ·ç‡ä¸ç›®æ ‡ä¸åŒï¼Œéœ€è¦é‡é‡‡æ ·
        let resampleRequired = false;
        let originalSampleRate = 0;
        
        // DOM elements
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const resetBtn = document.getElementById('reset-btn');
        const partialTranscript = document.getElementById('partial-transcript');
        const finalTranscript = document.getElementById('final-transcript');
        const llmResponse = document.getElementById('llm-response');
        const llmStatus = document.getElementById('llm-status');
        const history = document.getElementById('history');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const browserWarning = document.getElementById('browser-warning');
        
        // éŸ³é¢‘æ’­æ”¾ç›¸å…³å˜é‡
        let audioQueue = [];
        let isPlayingAudio = false;
        let pendingAudioBuffer = null;
        let currentAudioSource = null;
        let audioBufferQueue = []; // å­˜å‚¨æ­£åœ¨æ„å»ºçš„å¥å­éŸ³é¢‘å—
        let currentSentenceId = null; // å½“å‰æ­£åœ¨æ„å»ºçš„å¥å­ID
        
        // Check browser compatibility
        function checkBrowserCompatibility() {
            // Check if mediaDevices API is available
            if (!navigator.mediaDevices) {
                browserWarning.style.display = 'block';
                browserWarning.innerHTML = '<strong>é”™è¯¯:</strong> æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å½•åˆ¶åŠŸèƒ½ã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„Chromeã€Edgeæˆ–Firefoxæµè§ˆå™¨ã€‚';
                startBtn.disabled = true;
                return false;
            }
            
            // Check if getUserMedia is available
            if (!navigator.mediaDevices.getUserMedia) {
                browserWarning.style.display = 'block';
                browserWarning.innerHTML = '<strong>é”™è¯¯:</strong> æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®åŠŸèƒ½ã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„Chromeã€Edgeæˆ–Firefoxæµè§ˆå™¨ã€‚';
                startBtn.disabled = true;
                return false;
            }
            
            // Check if AudioContext is available
            if (!window.AudioContext && !window.webkitAudioContext) {
                browserWarning.style.display = 'block';
                browserWarning.innerHTML = '<strong>é”™è¯¯:</strong> æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å¤„ç†åŠŸèƒ½ã€‚è¯·ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„Chromeã€Edgeæˆ–Firefoxæµè§ˆå™¨ã€‚';
                startBtn.disabled = true;
                return false;
            }
            
            // Check if we're in a secure context (HTTPS or localhost)
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                browserWarning.style.display = 'block';
                browserWarning.innerHTML = '<strong>è­¦å‘Š:</strong> éº¦å…‹é£è®¿é—®å¯èƒ½éœ€è¦HTTPSè¿æ¥ã€‚å¦‚æœæ‚¨é‡åˆ°é—®é¢˜ï¼Œè¯·å°è¯•ä½¿ç”¨HTTPSæˆ–åœ¨æœ¬åœ°è¿è¡Œåº”ç”¨ã€‚';
            }
            
            return true;
        }
        
        // Initialize WebSocket connection
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(event) {
                console.log('WebSocket connected');
                updateStatus('idle', 'å·²è¿æ¥ï¼Œå‡†å¤‡å°±ç»ª');
                startBtn.disabled = !checkBrowserCompatibility();
            };
            
            socket.onmessage = function(event) {
                try {
                    // åˆ¤æ–­æ¶ˆæ¯ç±»å‹ï¼ˆæ–‡æœ¬æˆ–äºŒè¿›åˆ¶ï¼‰
                    if (typeof event.data === 'string') {
                        // JSONæ¶ˆæ¯
                        const data = JSON.parse(event.data);
                        
                        // å¦‚æœæ˜¯äºŒè¿›åˆ¶å¤´éƒ¨æ¶ˆæ¯ï¼Œå‡†å¤‡æ¥æ”¶äºŒè¿›åˆ¶æ•°æ®
                        if (data.type === 'tts_binary_header') {
                            // è®¾ç½®å½“å‰æ¥æ”¶çš„äºŒè¿›åˆ¶å¤´ä¿¡æ¯ï¼Œåç»­çš„äºŒè¿›åˆ¶æ•°æ®ä¼šä½¿ç”¨è¿™ä¸ª
                            window.currentBinaryHeader = data;
                            return;
                        }
                        
                        // å¤„ç†æ™®é€šJSONæ¶ˆæ¯
                        handleSocketMessage(data);
                    } else if (event.data instanceof Blob) {
                        // äºŒè¿›åˆ¶æ•°æ®ï¼Œé€šå¸¸æ˜¯åœ¨tts_binary_headerä¹‹å
                        if (window.currentBinaryHeader) {
                            handleBinaryAudioData(event.data, window.currentBinaryHeader);
                            window.currentBinaryHeader = null; // æ¸…é™¤å¤´ä¿¡æ¯
                        } else {
                            console.error('æ”¶åˆ°äºŒè¿›åˆ¶æ•°æ®ä½†æ²¡æœ‰å¯¹åº”çš„å¤´ä¿¡æ¯');
                        }
                    }
                } catch (e) {
                    console.error('Error processing message:', e);
                }
            };
            
            socket.onclose = function(event) {
                console.log('WebSocket closed');
                updateStatus('error', 'è¿æ¥å·²æ–­å¼€');
                startBtn.disabled = true;
                stopBtn.disabled = true;
                isRecording = false;
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateStatus('error', 'è¿æ¥é”™è¯¯');
            };
        }
        
        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudioContext() {
            try {
                if (audioContext) {
                    // å¦‚æœå·²ç»å­˜åœ¨å¹¶ä¸”çŠ¶æ€æ˜¯runningæˆ–suspendedï¼Œåˆ™ç›´æ¥ä½¿ç”¨
                    if (audioContext.state === "running" || audioContext.state === "suspended") {
                        if (audioContext.state === "suspended") {
                            audioContext.resume();
                        }
                        return true;
                    }
                    
                    // å¦‚æœçŠ¶æ€æ˜¯closedï¼Œåˆ™éœ€è¦åˆ›å»ºæ–°çš„
                    try {
                        audioContext.close();
                    } catch (e) {
                        console.warn("Error closing old audio context:", e);
                    }
                }
                
                // åˆ›å»ºæ–°çš„éŸ³é¢‘ä¸Šä¸‹æ–‡
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log(`Audio context initialized with sample rate: ${audioContext.sampleRate}Hz`);
                return true;
            } catch (e) {
                console.error('Failed to initialize audio context:', e);
                return false;
            }
        }
        
        // å°†Base64ç¼–ç çš„PCMæ•°æ®è§£ç ä¸ºArrayBuffer
        function decodeBase64ToPCM(base64) {
            const binaryString = window.atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // å°†PCMæ•°æ®è½¬æ¢ä¸ºAudioBuffer
        async function pcmToAudioBuffer(pcmData) {
            if (!audioContext) {
                if (!initAudioContext()) {
                    throw new Error("Failed to initialize audio context");
                }
            }
            
            // åˆ›å»º16ä½PCM AudioBuffer
            const audioBuffer = audioContext.createBuffer(1, pcmData.byteLength / 2, 16000);
            
            // è·å–éŸ³é¢‘é€šé“æ•°æ®
            const channelData = audioBuffer.getChannelData(0);
            
            // å°†PCMæ•°æ®è½¬æ¢ä¸ºFloat32Array
            const pcmInt16 = new Int16Array(pcmData);
            for (let i = 0; i < pcmInt16.length; i++) {
                // å°†16ä½PCMå€¼ï¼ˆ-32768åˆ°32767ï¼‰è½¬æ¢ä¸º-1.0åˆ°1.0èŒƒå›´çš„float
                channelData[i] = pcmInt16[i] / 32768.0;
            }
            
            return audioBuffer;
        }
        
        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleSocketMessage(data) {
            switch (data.type) {
                case 'partial_transcript':
                    partialTranscript.textContent = data.content;
                    break;
                
                case 'final_transcript':
                    finalTranscript.textContent = data.content;
                    // Add to history
                    addToHistory(data.content, 'user');
                    // Clear partial after a short delay
                    setTimeout(() => {
                        partialTranscript.textContent = '';
                    }, 1000);
                    break;
                
                case 'llm_status':
                    if (data.status === 'processing') {
                        updateStatus('thinking', 'AIæ€è€ƒä¸­...');
                        llmStatus.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div> AIæ€è€ƒä¸­...';
                        llmResponse.textContent = '';
                        
                        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœå°šæœªåˆå§‹åŒ–ï¼‰
                        initAudioContext();
                        
                        // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
                        stopAudioPlayback();
                        
                        // æ¸…ç©ºéŸ³é¢‘ç¼“å†²åŒº
                        audioBufferQueue = [];
                        currentSentenceId = null;
                    }
                    break;
                
                case 'llm_response':
                    // Show streaming response
                    llmResponse.textContent = data.content;
                    
                    // If response is complete
                    if (data.is_complete) {
                        // Update status
                        updateStatus('idle', 'å·²å®Œæˆ');
                        llmStatus.textContent = 'å›ç­”å·²å®Œæˆ';
                        
                        // Add to history
                        addToHistory(data.content, 'llm');
                        
                        // Clear status after delay
                        setTimeout(() => {
                            llmStatus.textContent = '';
                        }, 2000);
                    }
                    break;
                
                case 'tts_sentence_start':
                    // å¥å­å¼€å§‹æ ‡è®°ï¼Œè®°å½•å½“å‰å¥å­ID
                    currentSentenceId = data.sentence_id;
                    if (data.is_first) {
                        console.log(`å‡†å¤‡æ’­æ”¾ç¬¬ä¸€ä¸ªå¥å­: ${data.text}`);
                    }
                    break;
                
                case 'tts_sentence_end':
                    // å¥å­ç»“æŸæ ‡è®°ï¼Œç¡®ä¿æ‰€æœ‰å—éƒ½è¢«å¤„ç†
                    console.log(`å¥å­æ’­æ”¾å®Œæˆ: ${data.text}`);
                    
                    // å¦‚æœè¿˜æœ‰å¾…å¤„ç†çš„ç¼“å†²åŒºï¼Œå¼ºåˆ¶å¤„ç†
                    if (audioBufferQueue.length > 0 && currentSentenceId === data.sentence_id) {
                        handleCompleteSentence();
                    }
                    
                    // é‡ç½®å½“å‰å¥å­ID
                    if (currentSentenceId === data.sentence_id) {
                        currentSentenceId = null;
                    }
                    break;
                
                case 'tts_audio_chunk':
                    // å¤„ç†æµå¼TTSéŸ³é¢‘å—ï¼ˆå…¼å®¹æ—§ç‰ˆbase64æ ¼å¼ï¼‰
                    if (data.is_last_chunk) {
                        // è¿™æ˜¯æœ€åä¸€ä¸ªå—ï¼Œæ ‡è®°æµå¼æ’­æ”¾ç»“æŸ
                        console.log(`TTSæµå¼ç»“æŸ: ${data.text || "æœªçŸ¥æ–‡æœ¬"}`);
                        
                        // å¦‚æœè¿˜æœ‰å¾…å¤„ç†çš„ç¼“å†²åŒºï¼Œåˆå¹¶å¹¶æ’­æ”¾
                        if (audioBufferQueue.length > 0 && currentSentenceId) {
                            handleCompleteSentence();
                        }
                        
                        // é‡ç½®å½“å‰å¥å­ID
                        currentSentenceId = null;
                    } else if (data.audio) {
                        // è·å–è¿™ä¸ªå—çš„éŸ³é¢‘æ•°æ®
                        try {
                            // è§£ç éŸ³é¢‘æ•°æ®
                            const pcmData = decodeBase64ToPCM(data.audio);
                            
                            // å¤„ç†éŸ³é¢‘å—
                            handleAudioChunk(pcmData, data);
                        } catch (e) {
                            console.error('å¤„ç†éŸ³é¢‘å—å‡ºé”™:', e);
                        }
                    } else if (data.rawAudio) {
                        // ç›´æ¥å¤„ç†åŸå§‹éŸ³é¢‘æ•°æ®
                        handleAudioChunk(data.rawAudio, data);
                    }
                    break;
                
                case 'tts_audio':
                    // å¤„ç†è€çš„TTSéŸ³é¢‘æ ¼å¼ï¼ˆä¸ºäº†å…¼å®¹ï¼‰
                    if (data.audio) {
                        try {
                            const pcmData = decodeBase64ToPCM(data.audio);
                            playLegacyAudio(pcmData, data.is_first);
                        } catch (e) {
                            console.error('å¤„ç†å®Œæ•´éŸ³é¢‘å‡ºé”™:', e);
                        }
                    }
                    break;
                
                case 'status':
                    if (data.status === 'listening') {
                        updateStatus('listening', 'æ­£åœ¨å¬å–...');
                    } else if (data.status === 'stopped') {
                        updateStatus('idle', 'å·²åœæ­¢');
                    }
                    break;
                
                case 'error':
                    console.error('Server error:', data.message);
                    updateStatus('error', `é”™è¯¯: ${data.message}`);
                    llmStatus.textContent = data.message;
                    break;
                
                default:
                    console.log('Unhandled message type:', data.type, data);
            }
        }
        
        // å¤„ç†å•ä¸ªéŸ³é¢‘å—
        function handleAudioChunk(pcmData, data) {
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–
            if (!audioContext && !initAudioContext()) {
                console.error("æ— æ³•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡");
                return;
            }
            
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºæ´»åŠ¨çŠ¶æ€
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // å°†PCMæ•°æ®æ·»åŠ åˆ°å½“å‰å¥å­çš„ç¼“å†²åŒº
            pcmToAudioBuffer(pcmData).then(audioBuffer => {
                audioBufferQueue.push({
                    buffer: audioBuffer,
                    isFirst: data.is_first || data.chunk_number === 1,
                    text: data.text || "",
                    chunkNumber: data.chunk_number || 0
                });
                
                // å¦‚æœè¿™æ˜¯ç¬¬ä¸€ä¸ªå—ï¼Œå¹¶ä¸”æˆ‘ä»¬æ²¡æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ï¼Œåˆ™å¼€å§‹å¤„ç†å¥å­
                if ((data.is_first || data.chunk_number === 1) && !isPlayingAudio && audioQueue.length === 0) {
                    handleCompleteSentence();
                }
                
                // å¦‚æœç¼“å†²åŒºå·²ç»è¶³å¤Ÿå¤§ï¼Œä¹Ÿå¼€å§‹å¤„ç†
                if (audioBufferQueue.length >= 5) {
                    handleCompleteSentence();
                }
            });
        }
        
        // å¤„ç†å®Œæ•´çš„å¥å­ï¼ˆæˆ–å¥å­çš„ä¸€éƒ¨åˆ†ï¼‰
        function handleCompleteSentence() {
            if (audioBufferQueue.length === 0) return;
            
            // å°†å¤šä¸ªå°ç¼“å†²åŒºåˆå¹¶ä¸ºä¸€ä¸ª
            let totalLength = 0;
            let firstChunk = audioBufferQueue[0]; // è·å–ç¬¬ä¸€ä¸ªå—çš„ä¿¡æ¯
            
            // è®¡ç®—æ€»é•¿åº¦
            for (let item of audioBufferQueue) {
                totalLength += item.buffer.length;
            }
            
            // åˆ›å»ºåˆå¹¶åçš„ç¼“å†²åŒº
            const mergedBuffer = audioContext.createBuffer(1, totalLength, 16000);
            const channelData = mergedBuffer.getChannelData(0);
            
            // å¤åˆ¶æ•°æ®
            let offset = 0;
            for (let item of audioBufferQueue) {
                const itemData = item.buffer.getChannelData(0);
                channelData.set(itemData, offset);
                offset += item.buffer.length;
            }
            
            // å°†åˆå¹¶åçš„ç¼“å†²åŒºæ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ—
            playOrQueueBuffer(mergedBuffer, firstChunk.isFirst, firstChunk.text);
            
            // æ¸…ç©ºç¼“å†²åŒº
            audioBufferQueue = [];
        }
        
        // æ’­æ”¾æ—§ç‰ˆå®Œæ•´éŸ³é¢‘ï¼ˆä¸ºå…¼å®¹ä¿ç•™ï¼‰
        function playLegacyAudio(pcmData, isFirst) {
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–
            if (!audioContext && !initAudioContext()) {
                console.error("æ— æ³•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡");
                return false;
            }
            
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºæ´»åŠ¨çŠ¶æ€
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // è½¬æ¢ä¸ºAudioBufferå¹¶æ’­æ”¾
            pcmToAudioBuffer(pcmData).then(audioBuffer => {
                playOrQueueBuffer(audioBuffer, isFirst);
            });
        }
        
        // æ’­æ”¾æˆ–æ’é˜ŸéŸ³é¢‘ç¼“å†²åŒº
        function playOrQueueBuffer(audioBuffer, isFirst, text) {
            if (isFirst) {
                console.log(`å¼€å§‹æ’­æ”¾æ–°çš„éŸ³é¢‘: ${text || "æ— æ–‡æœ¬"}`);
            }
            
            if (isFirst || (!isPlayingAudio && audioQueue.length === 0)) {
                // ç›´æ¥æ’­æ”¾
                playAudioBuffer(audioBuffer);
            } else {
                // æ·»åŠ åˆ°é˜Ÿåˆ—
                audioQueue.push(audioBuffer);
            }
        }
        
        // æ’­æ”¾éŸ³é¢‘ç¼“å†²åŒº
        function playAudioBuffer(audioBuffer) {
            if (!audioContext) {
                console.error('Audio context not initialized');
                return false;
            }
            
            try {
                // åˆ›å»ºéŸ³é¢‘æº
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                // ä¿å­˜å½“å‰æ’­æ”¾çš„éŸ³é¢‘æºä»¥ä¾¿å¯ä»¥åœæ­¢
                currentAudioSource = source;
                
                // æ·»åŠ æ’­æ”¾ç»“æŸäº‹ä»¶å¤„ç†
                source.onended = () => {
                    console.log('Audio playback ended, queue length:', audioQueue.length);
                    currentAudioSource = null;
                    isPlayingAudio = false; // Reset playing flag
                    playNextAudio();
                };
                
                // å¼€å§‹æ’­æ”¾
                source.start(0);
                isPlayingAudio = true;
                console.log('Started playing audio, buffer length:', audioBuffer.length);
                
                return true;
            } catch (e) {
                console.error('Error playing audio:', e);
                isPlayingAudio = false;
                return false;
            }
        }
        
        // æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªéŸ³é¢‘
        function playNextAudio() {
            if (audioQueue.length > 0 && !isPlayingAudio) {
                // ä»é˜Ÿåˆ—ä¸­è·å–ä¸‹ä¸€ä¸ªéŸ³é¢‘
                const nextAudio = audioQueue.shift();
                console.log('Playing next audio from queue, remaining:', audioQueue.length);
                
                // æ’­æ”¾å®ƒ
                playAudioBuffer(nextAudio);
            } else {
                isPlayingAudio = false;
            }
        }
        
        // åœæ­¢å½“å‰éŸ³é¢‘æ’­æ”¾
        function stopAudioPlayback() {
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                    currentAudioSource = null;
                } catch (e) {
                    console.error('Error stopping audio:', e);
                }
            }
            
            // æ¸…ç©ºé˜Ÿåˆ—
            audioQueue = [];
            audioBufferQueue = [];
            isPlayingAudio = false;
        }
        
        // Update status indicator
        function updateStatus(state, message) {
            statusDot.className = `status-dot ${state}`;
            statusText.textContent = message;
        }
        
        // Add message to history
        function addToHistory(text, type) {
            const item = document.createElement('div');
            item.className = type === 'user' ? 'history-item-user' : 'history-item-llm';
            
            if (type === 'user') {
                item.textContent = `ğŸ‘¤ ${text}`;
            } else {
                item.textContent = `ğŸ¤– ${text}`;
            }
            
            history.prepend(item);
        }
        
        // é‡é‡‡æ ·å‡½æ•° - å°†ä»»æ„é‡‡æ ·ç‡è½¬æ¢ä¸º16kHz
        function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) {
                return buffer;
            }
            
            const sampleRateRatio = inputSampleRate / outputSampleRate;
            const newLength = Math.round(buffer.length / sampleRateRatio);
            const result = new Float32Array(newLength);
            
            let offsetResult = 0;
            let offsetBuffer = 0;
            
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                let accum = 0, count = 0;
                
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                    accum += buffer[i];
                    count++;
                }
                
                result[offsetResult] = accum / count;
                offsetResult++;
                offsetBuffer = nextOffsetBuffer;
            }
            
            return result;
        }
        
        // ä»Float32è½¬æ¢ä¸ºInt16 (PCM)
        function convertFloat32ToInt16(buffer) {
            const l = buffer.length;
            const buf = new Int16Array(l);
            
            for (let i = 0; i < l; i++) {
                // è½¬æ¢ä¸º16ä½æœ‰ç¬¦å·æ•´æ•°
                // å°†-1åˆ°1çš„èŒƒå›´è½¬æ¢ä¸º-32768åˆ°32767
                const s = Math.max(-1, Math.min(1, buffer[i]));
                buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            return buf;
        }
        
        // è®°å½•éŸ³é¢‘çŠ¶æ€ä¾›è¯Šæ–­
        function logAudioState(audioBuffer) {
            // æ¯10ç§’è®°å½•ä¸€æ¬¡éŸ³é¢‘çŠ¶æ€
            if (!logAudioState.lastLog || Date.now() - logAudioState.lastLog > 10000) {
                // åˆ†æéŸ³é¢‘å¹…åº¦
                let sum = 0, max = 0, min = 0;
                for (let i = 0; i < audioBuffer.length; i++) {
                    sum += Math.abs(audioBuffer[i]);
                    max = Math.max(max, audioBuffer[i]);
                    min = Math.min(min, audioBuffer[i]);
                }
                const avg = sum / audioBuffer.length;
                
                console.log(`éŸ³é¢‘çŠ¶æ€: å¹³å‡å¹…åº¦=${avg.toFixed(4)}, èŒƒå›´=${min.toFixed(4)}åˆ°${max.toFixed(4)}, é‡‡æ ·ç‡=${originalSampleRate}Hz${resampleRequired ? '(éœ€è¦é‡é‡‡æ ·)' : ''}`);
                
                // æ£€æµ‹éº¦å…‹é£å¯èƒ½çš„é™éŸ³çŠ¶æ€
                if (avg < 0.0001 && max - min < 0.001) {
                    console.warn("è­¦å‘Š: æ£€æµ‹åˆ°å¯èƒ½çš„é™éŸ³è¾“å…¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£");
                }
                
                logAudioState.lastLog = Date.now();
            }
        }
        
        // å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
        async function handleBinaryAudioData(blob, header) {
            try {
                // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–
                if (!audioContext) {
                    initAudioContext();
                }
                
                // å°†Blobè½¬æ¢ä¸ºArrayBuffer
                const arrayBuffer = await blob.arrayBuffer();
                
                // å¤„ç†éŸ³é¢‘å—
                const data = {
                    type: 'tts_audio_chunk',
                    is_chunk: true,
                    chunk_number: header.chunk_number,
                    is_first: header.is_first_chunk,
                    sentence_id: header.sentence_id,
                    session_id: header.session_id,
                    rawAudio: arrayBuffer // ç›´æ¥ä½¿ç”¨åŸå§‹éŸ³é¢‘æ•°æ®
                };
                
                // å¼€å§‹å¤„ç†éŸ³é¢‘å—
                handleAudioChunk(arrayBuffer, data);
                
                if (header.is_first_chunk) {
                    console.log(`å¼€å§‹æ’­æ”¾æ–°çš„äºŒè¿›åˆ¶éŸ³é¢‘æµ: å— #${header.chunk_number}`);
                }
            } catch (e) {
                console.error('å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®å‡ºé”™:', e);
            }
        }
        
        // Start audio recording and streaming
        async function startRecording() {
            try {
                // Check browser compatibility
                if (!checkBrowserCompatibility()) {
                    return;
                }
                
                // Request microphone access with fallbacks for different browsers
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                
                // Request microphone access
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                // Create audio context
                audioContext = new AudioContext();
                originalSampleRate = audioContext.sampleRate;
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡é‡‡æ ·
                resampleRequired = originalSampleRate !== SAMPLE_RATE;
                console.log(`åŸå§‹é‡‡æ ·ç‡: ${originalSampleRate}Hz, ç›®æ ‡é‡‡æ ·ç‡: ${SAMPLE_RATE}Hz, éœ€è¦é‡é‡‡æ ·: ${resampleRequired}`);
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                
                // Create script processor node for streaming audio
                processor = audioContext.createScriptProcessor(BUFFER_SIZE, CHANNELS, CHANNELS);
                
                processor.onaudioprocess = function(e) {
                    if (!isRecording || !socket || socket.readyState !== WebSocket.OPEN) return;
                    
                    // è·å–éŸ³é¢‘æ•°æ®
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // è®°å½•åŸå§‹éŸ³é¢‘çŠ¶æ€
                    logAudioState(inputData);
                    
                    // æ ¹æ®éœ€è¦é‡é‡‡æ ·
                    let audioToProcess = inputData;
                    if (resampleRequired) {
                        audioToProcess = downsampleBuffer(inputData, originalSampleRate, SAMPLE_RATE);
                    }
                    
                    // è½¬æ¢ä¸º16ä½PCM
                    const pcmData = convertFloat32ToInt16(audioToProcess);
                    
                    // å‘é€åˆ°æœåŠ¡å™¨
                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(pcmData.buffer);
                    }
                };
                
                // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                updateStatus('listening', 'æ­£åœ¨å¬å–...');
                
                // Update UI
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                // Send start command
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'start' }));
                }
                
            } catch (error) {
                console.error('Error starting recording:', error);
                
                let errorMessage = 'éº¦å…‹é£è®¿é—®é”™è¯¯';
                
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage = 'æ‰¾ä¸åˆ°éº¦å…‹é£è®¾å¤‡ã€‚è¯·ç¡®è®¤æ‚¨çš„è®¾å¤‡å·²æ­£ç¡®è¿æ¥ã€‚';
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'éº¦å…‹é£è®¿é—®è¢«æ‹’ç»ã€‚è¯·åœ¨æµè§ˆå™¨ä¸­å…è®¸éº¦å…‹é£è®¿é—®æƒé™ã€‚';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage = 'æ— æ³•è®¿é—®éº¦å…‹é£ã€‚å¯èƒ½è¢«å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºå ç”¨ã€‚';
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    errorMessage = 'éº¦å…‹é£ä¸ç¬¦åˆè¦æ±‚çš„å‚æ•°ã€‚';
                } else if (error.name === 'TypeError') {
                    errorMessage = 'æµè§ˆå™¨APIé”™è¯¯ã€‚è¯·å°è¯•ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„Chromeã€Edgeæˆ–Firefoxæµè§ˆå™¨ã€‚';
                }
                
                updateStatus('error', errorMessage);
                browserWarning.style.display = 'block';
                browserWarning.innerHTML = `<strong>é”™è¯¯:</strong> ${errorMessage}`;
            }
        }
        
        // Stop recording
        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            
            // Stop media stream tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            
            // Disconnect audio nodes
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            
            // Close audio context
            if (audioContext) {
                audioContext.close().catch(console.error);
                audioContext = null;
            }
            
            // Send stop command
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'stop' }));
            }
            
            // Update UI
            startBtn.disabled = false;
            stopBtn.disabled = true;
            updateStatus('idle', 'å·²åœæ­¢');
        }
        
        // Reset everything
        function resetSession() {
            // Stop recording if active
            if (isRecording) {
                stopRecording();
            }
            
            // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
            stopAudioPlayback();
            
            // Clear displays
            partialTranscript.textContent = '';
            finalTranscript.textContent = '';
            llmResponse.textContent = '';
            llmStatus.textContent = '';
            
            // Send reset command
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: "reset" }));
            }
            
            updateStatus('idle', 'å·²é‡ç½®');
        }
        
        // Event listeners
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        resetBtn.addEventListener('click', resetSession);
        
        // Initialize connection when page loads
        window.addEventListener('load', function() {
            // Check browser compatibility first
            checkBrowserCompatibility();
            // Initialize WebSocket
            initializeWebSocket();
        });
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (isRecording) {
                stopRecording();
            }
            if (socket) {
                socket.close();
            }
        });
    </script>
</body>
</html> 